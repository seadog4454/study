GAS LISTING boot.s 			page 1


   1              	.include "./define.s"
   1              	.set BOOT_LOAD, 0x7C00
   2              	.set BOOT_SIZE, 0x2000 #(1024 * 8)
   3              	.set SECT_SIZE, 512
   4              	.set BOOT_SECT, 0x10 #(.Lboot_BOOT_SIZE / .Lboot_SECT_SIZE)
   5              	.set BOOT_END, 0x9C00
   6              	.set KERNEL_SECT, 0x10 #(.Lboot_KERNEL_SIZE / .Lboot_SECT_SIZE)
   7              	.set KERNEL_SIZE, 8192
   8              	.set VRAM, 0x000A0000
   9              	.set KERNEL_LOAD, 0x00101000
  10              	.set VECT_BASE, 0x00100000
  11              	
  12              	.set RING_ITEM_SIZE, (1 << 4)
  13              	.set RING_INDEX_MASK, (RING_ITEM_SIZE - 1)
   2              	
   3              	.code16
   4              	
   5              	.section .text
   6              	.global _start
   7              	
   8              	_start:
   9 0000 EB58     	  jmp ipl
  10              	
  11              	  # BPB(BIOS Prameter Block)  
  12 0002 90909090 	  .fill 90 - (. - _start), 0x1, 0x90
  12      90909090 
  12      90909090 
  12      90909090 
  12      90909090 
  13              	
  14              	  # IPL(Initial Program Loader)
  15              	ipl:
  16 005a FA       	  cli
  17 005b B80000   	  mov $0x0000, %ax
  18 005e 8ED8     	  mov %ax, %ds
  19 0060 8EC0     	  mov %ax, %es
  20 0062 8ED0     	  mov %ax, %ss 
  21              	  #mov (.Lboot_BOOT_LOAD, %sp
  22 0064 BC007C   		mov $BOOT_LOAD, %sp
  23              	
  24 0067 FB       	  sti
  25              	
  26 0068 BB0000   		movw $drive_tmp, %bx
  27 006b C7870000 		movw $0x0, drive.no(%bx)
  27      0000
  28 0071 C7870200 		movw $0x0, drive.cyln.low(%bx)
  28      0000
  29 0077 C7870400 		movw $0x0, drive.head(%bx)
  29      0000
  30 007d C7870600 		movw $0x2, drive.sect(%bx)
  30      0200
  31              	
  32              	
  33 0083 88160000 		mov %dl, (drive_tmp)
  34 0087 680000   		push $.Lboot_s0
  35 008a E85700   	  call puts
  36 008d 83C402   	  add $0x2, %sp
GAS LISTING boot.s 			page 2


  37              	
  38 0090 B8007C   		mov $BOOT_LOAD, %ax
  39 0093 B90002   		mov $SECT_SIZE, %cx
  40 0096 BB1000   	  mov $BOOT_SECT, %bx
  41 0099 83EB01   		sub $0x1, %bx
  42 009c 01C1     		add %ax, %cx
  43              	
  44              	
  45 009e 51       	  push %cx
  46 009f 53       	  push %bx
  47 00a0 680000   	  push $drive_tmp
  48 00a3 E89C00   		call read_chs
  49 00a6 83C406   	  add $6, %sp
  50 00a9 39D8     		cmp %bx, %ax
  51 00ab 740C     	  jz .Lboot_10E
  52 00ad 680000   	  push $.Lboot_e0
  53 00b0 E83100   	  call puts
  54 00b3 83C402   	  add $2, %sp
  55 00b6 E84A00   	  call reboot
  56              	.Lboot_10E:
  57 00b9 E9B705   	  jmp stage_2
  58              	
  59              	
  60              	
  61 00bc 426F6F74 	.Lboot_s0: .string "Booting...\n\r"
  61      696E672E 
  61      2E2E0A0D 
  61      00
  62 00c9 4572726F 	.Lboot_e0: .string "Error:sector read"
  62      723A7365 
  62      63746F72 
  62      20726561 
  62      6400
  63              	#.Lboot_BOOT_LOAD: .word 0x7C00
  64              	#.Lboot_BOOT_SIZE: .word 0x2000 #(1024 * 8)
  65              	#.Lboot_SECT_SIZE: .word 512
  66              	#.Lboot_BOOT_SECT: .word 0x10 #(.Lboot_BOOT_SIZE / .Lboot_SECT_SIZE)
  67              	#.Lboot_BOOT_END: .word 0x9C00
  68              	#.Lboot_KERNEL_SECT: .word 0x10 #(.Lboot_KERNEL_SIZE / .Lboot_SECT_SIZE)
  69              	
  70 00db 90       	.align 2
  71 00dc 00000000 	drive_tmp: .space drive.size
  71      00000000 
  72              	
  73              	#.include "../modules/real/putc.s"
  74              	.include "../modules/real/puts.s"
   1              	.code16
   2              	
   3              	puts:
   4 00e4 55       	  push %bp
   5 00e5 89E5     	  mov %sp, %bp
   6              	
   7 00e7 50       	  push %ax
   8 00e8 53       	  push %bx
   9 00e9 56       	  push %si #arg1: pointer of strings
  10              	
  11 00ea 8B7604   	  mov 0x4(%bp), %si
GAS LISTING boot.s 			page 3


  12              	
  13 00ed B40E     	  mov $0x0E, %ah # output one char
  14 00ef BB0000   	  mov $0x0000, %bx
  15 00f2 FC       	  cld # DF = 0
  16              	
  17              	  
  18              	/*
  19              	for(i=0, AL != null; AL++){
  20              	  int 0x10 # put AL
  21              	}
  22              	*/
  23              	
  24              	
  25              	.loop1:
  26 00f3 AC       	  lodsb # AL = *SI++
  27 00f4 3C00     	  cmp $0, %al
  28 00f6 7404     	  je .L1
  29              	  
  30 00f8 CD10     	  int $0x10
  31 00fa EBF7     	  jmp .loop1
  32              	
  33              	.L1:
  34              	
  35 00fc 5E       	  pop %si
  36 00fd 5B       	  pop %bx
  37 00fe 58       	  pop %ax
  38              	
  39 00ff 89EC     	  mov %bp, %sp
  40 0101 5D       	  pop %bp
  41              	
  42 0102 C3       	  ret
  43              	 
  75              	.include "../modules/real/reboot.s"
   1              	.code16
   2              	
   3              	reboot:
   4 0103 680000   		push $s_reboot_signal
   5 0106 E8DBFF   		call puts
   6 0109 83C402   		add $0x2, %sp
   7              	
   8              	.Lreboot1:
   9 010c B410     		mov $0x10, %ah # wait input key
  10 010e CD16     		int $0x16 # bios call: input key
  11              	
  12 0110 3C20     		cmp $0x20, %al
  13 0112 75F8     		jne .Lreboot1
  14              	
  15              		
  16 0114 680000   		push $s_reboot_newline
  17 0117 E8CAFF   		call puts
  18 011a 83C402   		add $0x2, %sp
  19              	
  20 011d CD19     		int $0x19 # bios call: reboot
  21              	
  22 011f 0A0D5075 	s_reboot_signal: .string "\n\rPush SPACE key to reboot..."
  22      73682053 
  22      50414345 
GAS LISTING boot.s 			page 4


  22      206B6579 
  22      20746F20 
  23 013d 0A0D0A0D 	s_reboot_newline: .string "\n\r\n\r"
  23      00
  24              	
  25              	
  76              	.include "../modules/real/read_chs.s"
   1              	/*
   2              	 * read_chs(drive, sect, dst)
   3              	 * return: number of read sectors: ax register
   4              	 * args:
   5              	 *		drive: addr of struct drive
   6              	 *      no: drive number
   7              	 *      cyln: cylinder
   8              	 *      head: head
   9              	 *      sect: sector
  10              	 *		sect: number of sectors you want to read
  11              	 *		dst: 
  12              	 */
  13              	
  14              	.code16
  15              	
  16              	read_chs:
  17 0142 55       		push %bp
  18 0143 89E5     		mov %sp, %bp
  19              	
  20 0145 6A03     		push $3  # number of retries
  21 0147 6A00     		push $0 # number of read sector
  22              	
  23 0149 53       		push %bx
  24 014a 51       		push %cx
  25 014b 52       		push %dx
  26 014c 06       		push %es
  27 014d 56       		push %si
  28              	
  29 014e 8B7604   		mov 0x4(%bp), %si # src buff
  30              		
  31 0151 8AAC0200 	  mov drive.cyln.low(%si), %ch
  32 0155 8A8C0300 		mov drive.cyln.high(%si), %cl
  33 0159 C0E106   	  shl $6, %cl
  34 015c 0A8C0600 	  or drive.sect(%si), %cl
  35 0160 8AB40400 	  mov drive.head(%si), %dh
  36 0164 8A940000 	  mov drive.no(%si), %dl
  37 0168 8A14     	  mov (%si), %dl
  38 016a B80000   	  mov $0x0, %ax
  39 016d 8EC0     	  mov %ax, %es
  40 016f 8B5E08   	  mov 0x8(%bp), %bx # dist copy
  41              	
  42              	.read_chs1L:
  43 0172 B402     	  mov $0x2, %ah
  44 0174 8A4606   	  mov 0x6(%bp), %al
  45              	
  46 0177 CD13     	  int $0x13
  47 0179 7304     	  jnc .read_chs1E
  48              	
  49 017b B000     	  mov $0, %al
  50 017d EB0C     	  jmp .read_chs2E
GAS LISTING boot.s 			page 5


  51              	.read_chs1E:
  52              	  
  53 017f 3C00     	  cmp $0, %al
  54 0181 7508     	  jne .read_chs2E
  55              	
  56 0183 B80000   	  mov $0, %ax
  57 0186 FF4EFE   	  decw -0x2(%bp)
  58 0189 75E7     	  jnz .read_chs1L
  59              	.read_chs2E:
  60 018b B400     	  mov $0, %ah
  61              	
  62 018d 5E       	  pop %si
  63 018e 07       	  pop %es
  64 018f 5A       	  pop %dx
  65 0190 59       	  pop %cx
  66 0191 5B       	  pop %bx
  67              	
  68 0192 89EC     	  mov %bp, %sp
  69 0194 5D       	  pop %bp
  70              	
  71 0195 C3       	  ret
  72              	
  73              	
  74              	.section .data
  75              	
  76              	drive:
  77              		.struct 0
  77              	
  78              	.section .text
  79              	/* write boot signature in 0x200 */
  80              	
  81 0196 00000000 	.Lboot_boot_sig: .fill 0x1fe - (. - _start), 0x1, 0x0
  81      00000000 
  81      00000000 
  81      00000000 
  81      00000000 
  82 01fe 55AA     	BOOT_SIGNATURE: .word 0xAA55
  83              	
  84              	/*
  85              	 * Can't refer to a common label in real mode and protected mode.
  86              	 * Because these are assembled separately.
  87              	 * So, An absolute address is required for reference in both modes.
  88              	 * In addition, the address have to be specified in a location we understand easyly.
  89              	 * In this program, the address will be located after signature, 0xAA55.
  90              	 */
  91              	FONT:
  92 0200 0000     	FONT.seg: .word 0x0
  93 0202 0000     	FONT.off: .word 0x0
  94              	ACPI_DATA:
  95 0204 00000000 	ACPI_DATA.adr: .long 0x0
  96 0208 00000000 	ACPI_DATA.len: .long 0x0
  97              	
  98              	.include "../modules/real/itoa.s"
   1              	.code16
   2              	.section .text
   3              	
   4              	# void itoa(num, buff, size, radix, flag)
GAS LISTING boot.s 			page 6


   5              	# num:source addr
   6              	# buff:dist addr
   7              	# radix:set 2, 8, 10, or 16 
   8              	# flag:When set 
   9              	#                 1st bit: 0 padding on space
  10              	#                 2nd bit: add +/- sign
  11              	#                 3rd bit: treat as signed variable 
  12              	
  13              	
  14              	itoa:
  15 020c 55       	  push %bp
  16 020d 89E5     	  mov %sp, %bp
  17              	
  18              	# store register
  19 020f 50       	  push %ax
  20 0210 53       	  push %bx
  21 0211 51       	  push %cx
  22 0212 52       	  push %dx
  23 0213 56       	  push %si
  24 0214 57       	  push %di
  25              	
  26              	# get arguments
  27 0215 8B4604   	  mov 0x4(%bp), %ax # num
  28 0218 8B7606   	  mov 0x6(%bp), %si # buff
  29 021b 8B4E08   	  mov 0x8(%bp), %cx # size
  30 021e 8B5E0C   	  mov 0xc(%bp), %bx # flag
  31              	# The remaining arguments(radix: 0xa(%bp) ) will be assigend later.
  32 0221 89F7     	  mov %si, %di
  33 0223 01CF     	  add %cx, %di
  34 0225 4F       	  dec %di
  35              	
  36              	
  37              	
  38              	# detect signed variable
  39 0226 F7C30100 	  test $0b0001, %bx
  40 022a 7408     	  jz .Litoa1
  41 022c 83F800   	  cmp $0, %ax
  42 022f 7D03     	  jge .Litoa2
  43 0231 83CB02   	  or $0b0010, %bx
  44              	.Litoa1: 
  45              	.Litoa2:
  46              	
  47              	# detect add +/- sign
  48 0234 F7C30200 	  test $0b0010, %bx
  49 0238 7410     	  jz .Litoa3
  50 023a 83F800   	  cmp $0, %ax
  51 023d 7D07     	  jge .Litoa4
  52 023f F7D8     	  neg %ax
  53 0241 C6042D   	  movb $0x2d, (%si) # 0x2d == '-'
  54 0244 EB03     	  jmp .Litoa5
  55              	.Litoa4:
  56 0246 C6042B   	  movb $0x2b, (%si) # 0x2b == '+'
  57              	.Litoa5:
  58 0249 49       	  dec %cx
  59              	.Litoa3:
  60              	
  61              	# convert to ascii
GAS LISTING boot.s 			page 7


  62 024a 8B5E0A   	  mov 0xa(%bp), %bx
  63              	.LitoaLOOP1:
  64 024d BA0000   	  mov $0, %dx
  65 0250 F7F3     	  div %bx
  66 0252 89D6     	  mov %dx, %si
  67 0254 8A940000 	  movb ascii_table(%si), %dl
  68 0258 8815     	  mov %dl, (%di)
  69 025a 4F       	  dec %di
  70 025b 83F800   	  cmp $0, %ax
  71 025e E0ED     	  loopnz .LitoaLOOP1
  72              	.LotpaLOOPEND1:
  73              	
  74              	
  75              	# 0 padding in the space
  76 0260 83F900   	  cmp $0, %cx
  77 0263 740D     	  je .Litoa6
  78 0265 B020     	  mov $0x20, %al
  79 0267 837E0C04 	  cmp $0b0100, 0xc(%bp)
  80 026b 7502     	  jne .Litoa7
  81 026d B030     	  mov $0x30, %al
  82              	.Litoa7:
  83 026f FD       	  std
  84 0270 F3AA     	  rep stosb
  85              	.Litoa6:
  86              	
  87              	# return register
  88 0272 5F       	  pop %di
  89 0273 5E       	  pop %si
  90 0274 5A       	  pop %dx
  91 0275 59       	  pop %cx
  92 0276 5B       	  pop %bx
  93 0277 58       	  pop %ax
  94              	
  95              	# destroy stack frame
  96 0278 89EC     	  mov %bp, %sp
  97 027a 5D       	  pop %bp
  98 027b C3       	  ret
  99              	
 100              	
 101              	
 102 027c 30313233 	ascii_table: .string "0123456789ABCDEF"
 102      34353637 
 102      38394142 
 102      43444546 
 102      00
  99              	.include "../modules/real/get_drive_param.s"
   1              	/*
   2              	 * get_drive_param(drive);
   3              	 * return:
   4              	 *  sucsess: other than 0
   5              	 *  false: 0
   6              	 * arguments:
   7              	 *  arg1: drive struct(ref. read_chs.s)
   8              	 */
   9              	
  10              	.code16
  11              	
GAS LISTING boot.s 			page 8


  12              	get_drive_param:
  13 028d 55       	  push %bp
  14 028e 89E5     	  mov %sp, %bp
  15              	
  16 0290 53       	  push %bx
  17 0291 51       	  push %cx
  18 0292 06       	  push %es
  19 0293 56       	  push %si
  20 0294 57       	  push %di
  21              	
  22 0295 8B7604   	  mov 0x4(%bp), %si
  23              	
  24 0298 31C0     	  xor %ax, %ax
  25 029a 8EC0     	  mov %ax, %es
  26 029c 89C7     	  mov %ax, %di
  27              	
  28 029e B408     	  mov $8, %ah
  29 02a0 8A14     	  mov drive.no(%si), %dl
  30 02a2 CD13     	  int $0x13
  31 02a4 721B     	  jc .Lget_drive_param1
  32              	
  33 02a6 88C8     	  mov %cl, %al
  34 02a8 83E03F   	  and $0x3F, %ax
  35              	
  36 02ab C0E906   	  shr $6, %cl
  37 02ae C1C908   	  ror $8, %cx
  38 02b1 41       	  inc %cx
  39              	
  40 02b2 0FB6DE   	  movzx %dh, %bx
  41 02b5 43       	  inc %bx
  42              	
  43 02b6 894C02   	  mov %cx, drive.cyln.low(%si)
  44 02b9 895C04   	  mov %bx, drive.head(%si)
  45 02bc 894406   	  mov %ax, drive.sect(%si)
  46              	
  47 02bf EB03     	  jmp .Lget_drive_param2
  48              	
  49              	
  50              	.Lget_drive_param1:
  51 02c1 B80000   	  mov $0, %ax
  52              	
  53              	.Lget_drive_param2:
  54 02c4 5F       	  pop %di
  55 02c5 5E       	  pop %si
  56 02c6 07       	  pop %es
  57 02c7 59       	  pop %cx
  58 02c8 5B       	  pop %bx
  59              	
  60 02c9 89EC     	  mov %bp, %sp
  61 02cb 5D       	  pop %bp
  62              	
  63 02cc C3       	  ret
 100              	.include "../modules/real/get_font_adr.s"
   1              	/*
   2              	 * get_font_adr(adr)
   3              	 * return: void
   4              	 * arguments:
GAS LISTING boot.s 			page 9


   5              	 *  adr: Store position of the font address
   6              	 */
   7              	
   8              	.code16
   9              	
  10              	get_font_adr:
  11 02cd 55       	  push %bp
  12 02ce 89E5     	  mov %sp, %bp
  13              	
  14 02d0 50       	  push %ax
  15 02d1 53       	  push %bx
  16 02d2 56       	  push %si
  17 02d3 06       	  push %es
  18 02d4 55       	  push %bp
  19              	
  20 02d5 8B7604   	  mov 0x4(%bp), %si
  21              	  
  22              	  /*
  23              	   * font type(%bh):
  24              	   *  0x00: 8*8
  25              	   *  0x02: 8*14
  26              	   *  0x03: 8*8
  27              	   *  0x05: 9*14
  28              	   *  0x06: 8*16
  29              	   *  0x07: 9*16
  30              	   */
  31              	
  32 02d8 B83011   	  mov $0x1130, %ax # ax == 0x1130: get font address with "int 0x10"
  33 02db B706     	  mov $0x6, %bh # font type
  34 02dd CD10     	  int $0x10 # bios call: video service
  35              	
  36 02df 8C04     	  mov %es, (%si)
  37 02e1 896C02   	  mov %bp, 0x2(%si)
  38              	
  39 02e4 5D       	  pop %bp
  40 02e5 07       	  pop %es
  41 02e6 5E       	  pop %si
  42 02e7 5B       	  pop %bx
  43 02e8 58       	  pop %ax
  44              	
  45 02e9 89EC     	  mov %bp, %sp
  46 02eb 5D       	  pop %bp
  47              	
  48 02ec C3       	  ret
  49              	
 101              	.include "../modules/real/get_mem_info.s"
   1              	/*
   2              	 * get_mem_info(void)
   3              	 */
   4              	
   5              	 .code16
   6              	
   7              	 get_mem_info:
   8 02ed 6650     	  push %eax
   9 02ef 6653     	  push %ebx
  10 02f1 6651     	  push %ecx
  11 02f3 6652     	  push %edx
GAS LISTING boot.s 			page 10


  12 02f5 56       	  push %si
  13 02f6 57       	  push %di
  14 02f7 55       	  push %bp
  15              	
  16 02f8 680000   	  push $.Lget_mem_info_s3
  17 02fb E8E6FD   	  call puts
  18 02fe 83C402   	  add $2, %sp
  19              	
  20 0301 BD0000   	  mov $0x0, %bp # lines = 0
  21 0304 66BB0000 	  mov $0x0, %ebx # initialize index
  21      0000
  22              	
  23              	.Lget_mem_info_1L:
  24              	  /* bios call, get memory info  int 0x15(eax=0xE820)*/
  25 030a 66B820E8 	  mov $0x0000E820, %eax 
  25      0000
  26 0310 66B91400 	  mov $E820_RECORD_SIZE, %ecx # byte size
  26      0000
  27              	  
  28 0316 66BA5041 	  mov $0x534D4150, %edx # edx = "SMAP" = signature
  28      4D53
  29 031c BF0000   	  mov $.Lget_mem_info_b0, %di # distination: buffer
  30 031f CD15     	  int $0x15
  31              	
  32 0321 663D5041 	  cmp $0x534D4150, %eax
  32      4D53
  33 0327 7402     	  je .Lget_mem_info_1E
  34 0329 EB4C     	  jmp .Lget_mem_info_2E
  35              	
  36              	.Lget_mem_info_1E:
  37 032b 7302     	  jnc .Lget_mem_info_3E
  38 032d EB48     	  jmp .Lget_mem_info_2E
  39              	
  40              	.Lget_mem_info_3E:
  41 032f 57       	  push %di
  42 0330 E8F500   	  call put_mem_info
  43 0333 83C402   	  add $0x2, %sp
  44              	
  45 0336 668B4510 	  mov 0x10(%di), %eax
  46 033a 6683F803 	  cmp $3, %eax
  47 033e 750F     	  jne .Lget_mem_info_5E
  48              	
  49 0340 668B05   	  mov (%di), %eax
  50 0343 66A30000 	  mov %eax, (ACPI_DATA.adr)
  51              	  
  52 0347 668B4508 	  mov 0x8(%di), %eax
  53 034b 66A30000 	  mov %eax, (ACPI_DATA.len)
  54              	
  55              	.Lget_mem_info_5E:
  56 034f 6683FB00 	  cmp $0, %ebx
  57 0353 741C     	  jz .Lget_mem_info_6E
  58              	  
  59 0355 45       	  inc %bp
  60 0356 83E507   	  and $0x7, %bp
  61 0359 7516     	  jnz .Lget_mem_info_6E
  62              	  
  63 035b 680000   	  push $.Lget_mem_info_s0
GAS LISTING boot.s 			page 11


  64 035e E883FD   	  call puts
  65 0361 83C402   	  add $2, %sp
  66 0364 B410     	  mov $0x10, %ah
  67 0366 CD16     	  int $0x16
  68 0368 680000   	  push $.Lget_mem_info_s1
  69 036b E876FD   	  call puts
  70 036e 83C402   	  add $2, %sp
  71              	
  72              	.Lget_mem_info_6E:
  73              	
  74 0371 6683FB00 	  cmp $0, %ebx
  75 0375 7593     	  jne .Lget_mem_info_1L
  76              	.Lget_mem_info_2E:
  77              	  
  78 0377 680000   	  push $.Lget_mem_info_s5
  79 037a E867FD   	  call puts
  80 037d 83C402   	  add $2, %sp
  81              	
  82              	
  83 0380 5D       	  pop %bp
  84 0381 5F       	  pop %di
  85 0382 5E       	  pop %si
  86 0383 665A     	  pop %edx
  87 0385 6659     	  pop %ecx
  88 0387 665B     	  pop %ebx
  89 0389 6658     	  pop %eax
  90              	
  91 038b C3       	  ret
  92              	
  93              	.equ E820_RECORD_SIZE, 0x14
  94              	
  95 038c 203C6D6F 	.Lget_mem_info_s0: .string " <more...>"
  95      72652E2E 
  95      2E3E00
  96 0397 0D202020 	.Lget_mem_info_s1: .string "\r        \r"
  96      20202020 
  96      200D00
  97              	
  98 03a2 20453832 	.Lget_mem_info_s3: .ascii " E820 Memory Map\r\n"
  98      30204D65 
  98      6D6F7279 
  98      204D6170 
  98      0D0A
  99 03b4 20426173 	.Lget_mem_info_s4: .string " Base_____________ Length___________ Type____\r\n"
  99      655F5F5F 
  99      5F5F5F5F 
  99      5F5F5F5F 
  99      5F5F204C 
 100 03e4 202D2D2D 	.Lget_mem_info_s5: .string " ----------------- ----------------- --------\r\n"
 100      2D2D2D2D 
 100      2D2D2D2D 
 100      2D2D2D2D 
 100      2D2D202D 
 101              	
 102              	.align 4
 103 0414 00000000 	.Lget_mem_info_b0: .space E820_RECORD_SIZE
 103      00000000 
GAS LISTING boot.s 			page 12


 103      00000000 
 103      00000000 
 103      00000000 
 104              	
 105              	/*
 106              	 * put_mem_info(adr)
 107              	 * return void
 108              	 * arguments:
 109              	 *  adr: address to refer to the memory infomation
 110              	 */
 111              	
 112              	put_mem_info:
 113 0428 55       	  push %bp
 114 0429 89E5     	  mov %sp, %bp
 115              	
 116 042b 53       	  push %bx
 117 042c 56       	  push %si
 118              	
 119              	  # Base(64bit)
 120 042d 8B7604   	  mov 0x4(%bp), %si
 121 0430 BB0000   	  mov $.Lput_mem_info_p1, %bx
 122 0433 6A04     	  push $0b0100
 123 0435 6A10     	  push $16
 124 0437 6A04     	  push $4
 125 0439 53       	  push %bx
 126 043a FF7406   	  pushw 0x6(%si)
 127 043d E8CCFD   	  call itoa
 128 0440 83C40A   	  add $0xa, %sp
 129              	
 130              	  
 131 0443 83C304   	  add $4, %bx
 132 0446 6A04     	  push $0b0100
 133 0448 6A10     	  push $16
 134 044a 6A04     	  push $4
 135 044c 53       	  push %bx
 136 044d FF7404   	  pushw 0x4(%si)
 137 0450 E8B9FD   	  call itoa
 138 0453 83C40A   	  add $0xa, %sp
 139              	
 140 0456 BB0000   	  mov $.Lput_mem_info_p2, %bx
 141 0459 6A04     	  push $0b0100
 142 045b 6A10     	  push $16
 143 045d 6A04     	  push $4
 144 045f 53       	  push %bx
 145 0460 FF7402   	  pushw 0x2(%si)
 146 0463 E8A6FD   	  call itoa
 147 0466 83C40A   	  add $0xa, %sp
 148              	
 149 0469 83C304   	  add $4, %bx
 150 046c 6A04     	  push $0b0100
 151 046e 6A10     	  push $16
 152 0470 6A04     	  push $4
 153 0472 53       	  push %bx
 154 0473 FF34     	  pushw (%si)
 155 0475 E894FD   	  call itoa
 156 0478 83C40A   	  add $0xa, %sp
 157              	
GAS LISTING boot.s 			page 13


 158              	
 159              	  # Length(64bit)
 160 047b BB0000   	  mov $.Lput_mem_info_p3, %bx
 161 047e 6A04     	  push $0b0100
 162 0480 6A10     	  push $16
 163 0482 6A04     	  push $4
 164 0484 53       	  push %bx
 165 0485 FF740E   	  pushw 0xe(%si)
 166 0488 E881FD   	  call itoa
 167 048b 83C40A   	  add $0xa, %sp
 168              	
 169              	  
 170 048e 83C304   	  add $4, %bx
 171 0491 6A04     	  push $0b0100
 172 0493 6A10     	  push $16
 173 0495 6A04     	  push $4
 174 0497 53       	  push %bx
 175 0498 FF740C   	  pushw 0xc(%si)
 176 049b E86EFD   	  call itoa
 177 049e 83C40A   	  add $0xa, %sp
 178              	
 179 04a1 BB0000   	  mov $.Lput_mem_info_p4, %bx
 180 04a4 6A04     	  push $0b0100
 181 04a6 6A10     	  push $16
 182 04a8 6A04     	  push $4
 183 04aa 53       	  push %bx
 184 04ab FF740A   	  pushw 0xa(%si)
 185 04ae E85BFD   	  call itoa
 186 04b1 83C40A   	  add $0xa, %sp
 187              	
 188 04b4 83C304   	  add $4, %bx
 189 04b7 6A04     	  push $0b0100
 190 04b9 6A10     	  push $16
 191 04bb 6A04     	  push $4
 192 04bd 53       	  push %bx
 193 04be FF7408   	  pushw 0x8(%si)
 194 04c1 E848FD   	  call itoa
 195 04c4 83C40A   	  add $0xa, %sp
 196              	
 197              	  # Type(64bit)
 198 04c7 BB0000   	  mov $.Lput_mem_info_p5, %bx
 199 04ca 6A04     	  push $0b0100
 200 04cc 6A10     	  push $16
 201 04ce 6A04     	  push $4
 202 04d0 53       	  push %bx
 203 04d1 FF7412   	  pushw 0x12(%si)
 204 04d4 E835FD   	  call itoa
 205 04d7 83C40A   	  add $0xa, %sp
 206              	
 207              	  
 208 04da 83C304   	  add $4, %bx
 209 04dd 6A04     	  push $0b0100
 210 04df 6A10     	  push $16
 211 04e1 6A04     	  push $4
 212 04e3 53       	  push %bx
 213 04e4 FF7410   	  pushw 0x10(%si)
 214 04e7 E822FD   	  call itoa
GAS LISTING boot.s 			page 14


 215 04ea 83C40A   	  add $0xa, %sp
 216              	
 217 04ed 680000   	  push $.Lput_mem_info_s1
 218 04f0 E8F1FB   	  call puts
 219 04f3 83C402   	  add $2, %sp 
 220              	
 221 04f6 8B5C10   	  mov 0x10(%si), %bx
 222 04f9 83E307   	  and $0x7, %bx
 223 04fc D1E3     	  shl $1, %bx
 224 04fe 81C30000 	  add $.Lput_mem_info_t0, %bx
 225 0502 FF37     	  pushw (%bx)
 226 0504 E8DDFB   	  call puts
 227 0507 83C402   	  add $2, %sp
 228              	
 229 050a 5E       	  pop %si
 230 050b 5B       	  pop %bx
 231              	
 232 050c 89EC     	  mov %bp, %sp
 233 050e 5D       	  pop %bp
 234              	
 235              	
 236              	
 237 050f C3       	  ret
 238              	
 239 0510 20       	.Lput_mem_info_s1: .ascii " "
 240              	
 241 0511 5A5A5A5A 	.Lput_mem_info_p1: .ascii "ZZZZZZZZ_"
 241      5A5A5A5A 
 241      5F
 242 051a 5A5A5A5A 	.Lput_mem_info_p2: .ascii "ZZZZZZZZ "
 242      5A5A5A5A 
 242      20
 243 0523 5A5A5A5A 	.Lput_mem_info_p3: .ascii "ZZZZZZZZ_"
 243      5A5A5A5A 
 243      5F
 244 052c 5A5A5A5A 	.Lput_mem_info_p4: .ascii "ZZZZZZZZ "
 244      5A5A5A5A 
 244      20
 245 0535 5A5A5A5A 	.Lput_mem_info_p5: .string "ZZZZZZZZ"
 245      5A5A5A5A 
 245      00
 246              	
 247 053e 2028556E 	.Lput_mem_info_s2: .string " (Unknown)\n\r"
 247      6B6E6F77 
 247      6E290A0D 
 247      00
 248 054b 20287573 	.Lput_mem_info_s3: .string " (usable)\n\r"
 248      61626C65 
 248      290A0D00 
 249 0557 20287265 	.Lput_mem_info_s4: .string " (reserved)\n\r"
 249      73657276 
 249      6564290A 
 249      0D00
 250 0565 20284143 	.Lput_mem_info_s5: .string " (ACPI data)\n\r"
 250      50492064 
 250      61746129 
 250      0A0D00
GAS LISTING boot.s 			page 15


 251 0574 20284143 	.Lput_mem_info_s6: .string " (ACPI NVS)\n\r"
 251      5049204E 
 251      5653290A 
 251      0D00
 252 0582 20286261 	.Lput_mem_info_s7: .string " (bad memory)\n\r"
 252      64206D65 
 252      6D6F7279 
 252      290A0D00 
 253              	
 254 0592 00000000 	.Lput_mem_info_t0: .word .Lput_mem_info_s2, .Lput_mem_info_s3, .Lput_mem_info_s4, .Lput_mem_info_s5
 254      00000000 
 254      00000000 
 254      00000000 
 102              	.include "../modules/real/kbc.s"
   1              	/*
   2              	 * KBC_Data_Write(data)
   3              	 * return:
   4              	 *  sucsess: other than o
   5              	 *  false: 0
   6              	 * argumetns:
   7              	 *  data: the value to write buffer in KBC
   8              	 */
   9              	
  10              	.code16
  11              	
  12              	KBC_Data_Write:
  13 05a2 55       	  push %bp
  14 05a3 89E5     	  mov %sp, %bp
  15              	
  16 05a5 51       	  push %cx
  17              	
  18 05a6 B90000   	  mov $0, %cx
  19              	
  20              	# read KBC status
  21              	.LKBC_Data_Write_10L:
  22 05a9 E464     	  in $0x64, %al # port KBC status
  23 05ab A802     	  test $0x02, %al # Is writeable
  24 05ad E0FA     	  loopnz .LKBC_Data_Write_10L
  25              	  
  26 05af 83F900   	  cmp $0, %cx
  27 05b2 7405     	  jz .LKBC_Data_Write_20E
  28              	
  29 05b4 8A4604   	  mov 0x4(%bp), %al
  30 05b7 E660     	  out %al, $0x60
  31              	
  32              	.LKBC_Data_Write_20E:
  33              	  
  34 05b9 89C8     	  mov %cx, %ax
  35              	
  36 05bb 59       	  pop %cx
  37              	
  38 05bc 89EC     	  mov %bp, %sp
  39 05be 5D       	  pop %bp
  40              	
  41 05bf C3       	  ret
  42              	
  43              	
GAS LISTING boot.s 			page 16


  44              	
  45              	/*
  46              	 * KBC_Data_Read(data)
  47              	 * return:
  48              	 *  sucsess: Other than 0
  49              	 *  false: 0
  50              	 * arguments:
  51              	 *  data: Address to store read value from KBC
  52              	 */
  53              	
  54              	KBC_Data_Read:
  55 05c0 55       	  push %bp
  56 05c1 89E5     	  mov %sp, %bp
  57              	
  58 05c3 51       	  push %cx
  59 05c4 57       	  push %di
  60              	
  61 05c5 B90000   	  mov $0, %cx
  62              	
  63              	.LKBC_Data_Read_10L:
  64 05c8 E464     	  in $0x64, %al # KBC status
  65 05ca A801     	  test $0x01, %al # Is readable
  66 05cc E1FA     	  loopz .LKBC_Data_Read_10L
  67              	
  68 05ce 83F900   	  cmp $0, %cx
  69 05d1 7409     	  jz .LKBC_Data_Read_20E
  70              	
  71 05d3 B400     	  mov $0x0, %ah
  72 05d5 E460     	  in $0x60, %al # read data
  73              	
  74 05d7 8B7E04   	  mov 0x4(%bp), %di
  75 05da 8905     	  mov %ax, (%di)
  76              	.LKBC_Data_Read_20E:
  77              	
  78 05dc 89C8     	  mov %cx, %ax
  79              	
  80 05de 5F       	  pop %di
  81 05df 59       	  pop %cx
  82              	
  83 05e0 89EC     	  mov %bp, %sp
  84 05e2 5D       	  pop %bp
  85              	
  86 05e3 C3       	  ret
  87              	
  88              	
  89              	/*
  90              	 * KBC_Cmd_Write(Cmd)
  91              	 * return:
  92              	 *  sucsess: Other than 0
  93              	 *  false: 0
  94              	 * arguemnts:
  95              	 *  Cmd: command to send to KBC
  96              	 */
  97              	
  98              	KBC_Cmd_Write:
  99 05e4 55       	  push %bp
 100 05e5 89E5     	  mov %sp, %bp
GAS LISTING boot.s 			page 17


 101              	
 102 05e7 51       	  push %cx
 103              	
 104 05e8 B90000   	  mov $0, %cx
 105              	.LKBC_Cmd_Write_10L:
 106              	
 107 05eb E464     	  in $0x64, %al # KBC status
 108 05ed A802     	  test $0x02, %al
 109 05ef E0FA     	  loopnz .LKBC_Cmd_Write_10L
 110              	
 111 05f1 83F900   	  cmp $0, %cx
 112 05f4 7405     	  jz .LKBC_Cmd_Write_20E
 113              	
 114 05f6 8A4604   	  mov 0x04(%bp), %al
 115 05f9 E664     	  out %al, $0x64 # KCB cmd write
 116              	.LKBC_Cmd_Write_20E:
 117              	
 118              	
 119 05fb 89C8     	  mov %cx, %ax
 120              	
 121 05fd 59       	  pop %cx
 122              	
 123 05fe 89EC     	  mov %bp, %sp
 124 0600 5D       	  pop %bp
 125              	
 126 0601 C3       	  ret
 103              	.include "../modules/real/read_lba.s"
   1              	/*
   2              	 * read_lba(drive, lba, sect , dst)
   3              	 * arguments:
   4              	 *	drive: struct drive
   5              	 *	lba: LBA
   6              	 *	sect: read sector
   7              	 *	dst:	store address
   8              	 */
   9              	
  10              	read_lba:
  11 0602 55       	 	push %bp
  12 0603 89E5     		mov %sp, %bp
  13              	
  14 0605 56       		push %si
  15              	
  16 0606 8B7604   		mov 0x4(%bp), %si
  17              		
  18 0609 8B4606   		mov 0x6(%bp), %ax
  19              		
  20 060c 50       		push %ax
  21 060d 680000   		push $.Lread_lba_chs
  22 0610 56       		push %si
  23 0611 E82400   		call lba_chs
  24 0614 83C406   		add $0x6, %sp
  25              	
  26 0617 8A04     		mov drive.no(%si), %al
  27 0619 A20000   		mov %al, (.Lread_lba_chs + drive.no)
  28              	
  29 061c FF760A   		pushw 0xa(%bp)
  30 061f FF7608   		pushw 0x8(%bp)
GAS LISTING boot.s 			page 18


  31 0622 680000   		push $.Lread_lba_chs
  32 0625 E81AFB   		call read_chs
  33 0628 83C406   		add $0x6, %sp
  34              	
  35 062b 5E       		pop %si
  36 062c 89EC     		mov %bp, %sp
  37 062e 5D       		pop %bp
  38              	
  39 062f C3       		ret
  40              	
  41              	.align 2
  42 0630 00000000 	.Lread_lba_chs: .space drive.size
  42      00000000 
 104              	.include "../modules/real/lba_chs.s"
   1              	/*
   2              	 * lba_chs(drive, drv_chs, lba)
   3              	 * arguments:
   4              	 *  drive: struct drive
   5              	 *  drb_chs: struct drive to chs
   6              	 *  lba : sector number
   7              	 */
   8              	
   9              	 lba_chs:
  10 0638 55       	  push %bp
  11 0639 89E5     	  mov %sp, %bp
  12              	
  13 063b 50       	  push %ax
  14 063c 53       	  push %bx
  15 063d 52       	  push %dx
  16 063e 56       	  push %si
  17 063f 57       	  push %di
  18              	
  19 0640 8B7604   	  mov 0x4(%bp), %si
  20 0643 8B7E06   	  mov 0x6(%bp), %di
  21              	
  22              	  # get sectors per cylinder
  23 0646 8A4404   	  mov drive.head(%si), %al # AL = max heads
  24 0649 F66406   	  mulb drive.sect(%si)
  25 064c 89C3     	  mov %ax, %bx
  26              	  
  27 064e BA0000   	  mov $0, %dx
  28 0651 8B4608   	  mov 0x8(%bp), %ax
  29 0654 F7F3     	  div %bx
  30              	
  31 0656 894502   	  mov %ax, drive.cyln.low(%di)
  32              	
  33 0659 89D0     	  mov %dx, %ax
  34 065b F67406   	  divb  drive.sect(%si)
  35              	
  36 065e 0FB6D4   	  movzx %ah, %dx
  37 0661 42       	  inc %dx
  38              	
  39 0662 B400     	  mov $0x00 , %ah
  40              	
  41 0664 894504   	  mov %ax, drive.head(%di)
  42 0667 895506   	  mov %dx, drive.sect(%di)
  43              	
GAS LISTING boot.s 			page 19


  44 066a 5F       	  pop %di
  45 066b 5E       	  pop %si
  46 066c 5A       	  pop %dx
  47 066d 5B       	  pop %bx
  48 066e 58       	  pop %ax
  49              	
  50 066f 89EC     	  mov %bp, %sp
  51 0671 5D       	  pop %bp
  52              	
  53 0672 C3       	  ret
  54              	
 105              	
 106              	stage_2:
 107 0673 680000   	  push $.Lboot_s2
 108 0676 E86BFA   	  call puts
 109 0679 83C402   	  add $0x2, %sp
 110              	
 111 067c 680000   	  push $drive_tmp
 112 067f E80BFC   	  call get_drive_param
 113 0682 83C402   	  add $2, %sp
 114 0685 83F800   	  cmp $0, %ax
 115 0688 7509     	  jne .Lboot_5E
 116              	  
 117 068a E857FA   	  call puts
 118 068d 83C402   	  add $2, %sp
 119 0690 E870FA   	  call reboot
 120              	
 121              	.Lboot_5E:
 122 0693 680000   	  push $.Lboot_test
 123 0696 E84BFA   	  call puts
 124 0699 83C402   	  add $2, %sp
 125              	
 126 069c BB0000   	  movw $drive_tmp, %bx
 127              	  
 128 069f 8B07     	  mov drive.no(%bx), %ax
 129 06a1 6A04     	  push $0b0100
 130 06a3 6A10     	  push $16
 131 06a5 6A02     	  push $2
 132 06a7 680000   	  push $.Lboot_p1
 133 06aa 50       	  push %ax
 134 06ab E85EFB   	  call itoa
 135 06ae 83C40A   	  add $0xa, %sp
 136              	
 137              	
 138 06b1 8B4702   	  mov drive.cyln.low(%bx), %ax
 139 06b4 6A04     	  push $0b0100
 140 06b6 6A10     	  push $16
 141 06b8 6A04     	  push $4
 142 06ba 680000   	  push $.Lboot_p2
 143 06bd 50       	  push %ax
 144 06be E84BFB   	  call itoa
 145 06c1 83C40A   	  add $0xa, %sp
 146              	
 147              	
 148 06c4 8B4704   	  mov drive.head(%bx), %ax
 149 06c7 6A04     	  push $0b0100
 150 06c9 6A10     	  push $16
GAS LISTING boot.s 			page 20


 151 06cb 6A02     	  push $2
 152 06cd 680000   	  push $.Lboot_p3
 153 06d0 50       	  push %ax
 154 06d1 E838FB   	  call itoa
 155 06d4 83C40A   	  add $0xa, %sp
 156              	
 157 06d7 8B4706   	  mov drive.sect(%bx), %ax
 158 06da 6A04     	  push $0b0100
 159 06dc 6A10     	  push $16
 160 06de 6A02     	  push $2
 161 06e0 680000   	  push $.Lboot_p4
 162 06e3 50       	  push %ax
 163 06e4 E825FB   	  call itoa
 164 06e7 83C40A   	  add $0xa, %sp
 165              	
 166 06ea 680000   	  push $.Lboot_s3
 167 06ed E8F4F9   	  call puts
 168 06f0 83C402   	  add $0x2, %sp
 169              	
 170 06f3 EB59     	  jmp stage_3rd
 171              	
 172 06f5 326E6420 	.Lboot_s2: .string "2nd stage...\r\n"
 172      73746167 
 172      652E2E2E 
 172      0D0A00
 173 0704 43616E27 	.Lboot_e1: .string "Can't get drive parameter." 
 173      74206765 
 173      74206472 
 173      69766520 
 173      70617261 
 174 071f 20447269 	.Lboot_s3: .ascii " Drive:0x"
 174      76653A30 
 174      78
 175 0728 20202C20 	.Lboot_p1: .ascii "  , C:0x"
 175      433A3078 
 176 0730 20202020 	.Lboot_p2: .ascii "    , H:0x"
 176      2C20483A 
 176      3078
 177 073a 20202C20 	.Lboot_p3: .ascii "  , S:0x"
 177      533A3078 
 178 0742 20200D0A 	.Lboot_p4: .string "  \r\n"
 178      00
 179 0747 74657374 	.Lboot_test: .string "test\r\n"
 179      0D0A00
 180              	
 181              	
 182              	
 183              	stage_3rd:
 184 074e 680000   	  push $.Lboot_3rd_s0
 185 0751 E890F9   	  call puts
 186 0754 83C402   	  add $2, %sp
 187              	
 188 0757 680000   	  push $FONT
 189 075a E870FB   	  call get_font_adr
 190 075d 83C402   	  add $2, %sp
 191              	
 192 0760 6A04     	  push $0b0100
GAS LISTING boot.s 			page 21


 193 0762 6A10     	  push $16
 194 0764 6A04     	  push $4
 195 0766 680000   	  push $.Lboot_3rd_p1
 196 0769 FF360000 	  pushw (FONT.seg)
 197 076d E89CFA   	  call itoa
 198 0770 83C40A   	  add $0xa, %sp
 199              	
 200 0773 6A04     	  push $0b0100
 201 0775 6A10     	  push $16
 202 0777 6A04     	  push $4
 203 0779 680000   	  push $.Lboot_3rd_p2
 204 077c FF360000 	  pushw (FONT.off)
 205 0780 E889FA   	  call itoa
 206 0783 83C40A   	  add $0xa, %sp
 207              	
 208 0786 680000   	  push $.Lboot_3rd_s1
 209 0789 E858F9   	  call puts
 210 078c 83C402   	  add $2, %sp
 211              	
 212 078f E85BFB   	  call get_mem_info
 213              	
 214 0792 66A10000 	  mov (ACPI_DATA.adr), %eax
 215 0796 6683F800 	  cmp $0, %eax
 216 079a 742D     	  je .Lboot_3rd_10E
 217              	
 218 079c 6A04     	  push $0b0100
 219 079e 6A10     	  push $0x10
 220 07a0 6A04     	  push $0x4
 221 07a2 680000   	  push $.Lboot_3rd_p4
 222 07a5 50       	  push %ax
 223 07a6 E863FA   	  call itoa
 224 07a9 83C40A   	  add $0xa, %sp
 225              	
 226 07ac 66C1E810 	  shr $0x10, %eax
 227              	 
 228 07b0 6A04     	  push $0b0100
 229 07b2 6A10     	  push $0x10
 230 07b4 6A04     	  push $0x4
 231 07b6 680000   	  push $.Lboot_3rd_p3
 232 07b9 50       	  push %ax
 233 07ba E84FFA   	  call itoa
 234 07bd 83C40A   	  add $0xa, %sp
 235              	
 236              	
 237 07c0 680000   	  push $.Lboot_3rd_s2
 238 07c3 E81EF9   	  call puts
 239 07c6 83C402   	  add $2, %sp
 240              	
 241              	.Lboot_3rd_10E:
 242              	
 243 07c9 EB42     	  jmp stage_4
 244              	
 245              	
 246 07cb 33726420 	.Lboot_3rd_s0: .string "3rd stage...\n\r"
 246      73746167 
 246      652E2E2E 
 246      0A0D00
GAS LISTING boot.s 			page 22


 247 07da 20466F6E 	.Lboot_3rd_s1: .ascii " Font address="
 247      74206164 
 247      64726573 
 247      733D
 248 07e8 5A5A5A5A 	.Lboot_3rd_p1: .ascii "ZZZZ:"
 248      3A
 249 07ed 5A5A5A5A 	.Lboot_3rd_p2: .string "ZZZZ\n\r"
 249      0A0D00
 250 07f4 0A0D00   	.string "\n\r"
 251              	
 252 07f7 20414350 	.Lboot_3rd_s2: .ascii " ACPI data="
 252      49206461 
 252      74613D
 253 0802 5A5A5A5A 	.Lboot_3rd_p3: .ascii "ZZZZ"
 254 0806 5A5A5A5A 	.Lboot_3rd_p4: .string "ZZZZ\r\n"
 254      0D0A00
 255              	
 256              	
 257              	
 258              	stage_4:
 259              	
 260 080d 680000   	  push $.Lstage_4_s0
 261 0810 E8D1F8   	  call puts
 262 0813 83C402   	  add $0x2, %sp
 263              	
 264 0816 FA       	  cli
 265              	  
 266 0817 68AD00   	  push $0xAD # invalidate keyboard
 267 081a E8C7FD   	  call KBC_Cmd_Write
 268 081d 83C402   	  add $0x2, %sp
 269              	
 270 0820 68D000   	  push $0xD0 # setting: read value of output port
 271 0823 E8BEFD   	  call KBC_Cmd_Write
 272 0826 83C402   	  add $0x2, %sp
 273              	
 274 0829 680000   	  push $.Lstage_4_key # read value of output port
 275 082c E891FD   	  call KBC_Data_Read
 276 082f 83C402   	  add $0x2, %sp
 277              	
 278 0832 8A1E0000 	  mov (.Lstage_4_key), %bl 
 279 0836 80CB02   	  or $0x2, %bl # activate A20 gate, A20 gate has bit1 of output port.
 280              	
 281 0839 68D100   	  push $0xD1 # setting: write value to output port
 282 083c E8A5FD   	  call KBC_Cmd_Write
 283 083f 83C402   	  add $0x2, %sp
 284              	
 285 0842 53       	  push %bx # write value to output port
 286 0843 E85CFD   	  call KBC_Data_Write
 287 0846 83C402   	  add $0x2, %sp
 288              	
 289 0849 68AE00   	  push $0xAE # activate keyboard
 290 084c E895FD   	  call KBC_Cmd_Write
 291 084f 83C402   	  add $0x2, %sp
 292              	
 293 0852 FB       	  sti
 294              	 
 295 0853 680000   	  push $.Lstage_4_s1
GAS LISTING boot.s 			page 23


 296 0856 E88BF8   	  call puts
 297 0859 83C402   	  add $0x2, %sp
 298              	
 299 085c 680000   	  push $.Lstage_4_s2
 300 085f E882F8   	  call puts
 301 0862 83C402   	  add $0x2, %sp
 302              	
 303 0865 BB0000   	  mov $0x0, %bx
 304              	.Lstage_4_10L:
 305              	
 306 0868 B400     	  mov $0x00, %ah
 307 086a CD16     	  int $0x16
 308              	
 309 086c 3A063100 	  cmp 0x31, %al
 310 0870 7266     	  jb .Lstage_4_10E
 311              	  
 312 0872 3C33     	  cmp $0x33, %al
 313 0874 7762     	  ja .Lstage_4_10E
 314              	
 315 0876 88C1     	  mov %al, %cl
 316 0878 FEC9     	  dec %cl
 317 087a 80E103   	  and $0x03, %cl
 318 087d B80100   	  mov $0x0001, %ax
 319 0880 D3E0     	  shl %cl, %ax
 320 0882 31C3     	  xor %ax, %bx
 321              	
 322 0884 FA       	  cli
 323              	
 324 0885 68AD00   	  push $0xAD
 325 0888 E859FD   	  call KBC_Cmd_Write
 326 088b 83C402   	  add $0x2, %sp
 327              	
 328 088e 68ED00   	  push $0xED
 329 0891 E80EFD   	  call KBC_Data_Write
 330 0894 83C402   	  add $0x2, %sp
 331              	
 332 0897 680000   	  push $.Lstage_4_key
 333 089a E823FD   	  call KBC_Data_Read
 334 089d 83C402   	  add $0x2, %sp
 335              	
 336 08a0 803E0000 	  cmpb $0xFA, (.Lstage_4_key)
 336      FA
 337 08a5 7509     	  jne .Lstage_4_11F
 338              	
 339 08a7 53       	  push %bx
 340 08a8 E8F7FC   	  call KBC_Data_Write
 341 08ab 83C402   	  add $0x2, %sp
 342              	
 343 08ae EB1C     	  jmp .Lstage_4_11E
 344              	.Lstage_4_11F:
 345              	  
 346 08b0 6A04     	  push $0b0100
 347 08b2 6A10     	  push $0x10
 348 08b4 6A02     	  push $0x2
 349 08b6 680000   	  push $.Lstage_4_e1
 350 08b9 FF360000 	  pushw (.Lstage_4_key)
 351 08bd E84CF9   	  call itoa
GAS LISTING boot.s 			page 24


 352 08c0 83C40A   	  add $0xA, %sp
 353              	
 354 08c3 680000   	  push $.Lstage_4_e0
 355 08c6 E81BF8   	  call puts
 356 08c9 83C402   	  add $0x2, %sp
 357              	
 358              	.Lstage_4_11E:
 359 08cc 68AE00   	    push $0xAE
 360 08cf E812FD   	    call KBC_Cmd_Write
 361 08d2 83C402   	    add $0x2, %sp
 362              	
 363              	
 364 08d5 FB       	  sti
 365              	  
 366 08d6 EB90     	  jmp .Lstage_4_10L
 367              	
 368              	.Lstage_4_10E:
 369              	
 370 08d8 680000   	  push $.Lstage_4_s3
 371 08db E806F8   	  call puts
 372 08de 83C402   	  add $0x2, %sp
 373              	
 374 08e1 EB48     	  jmp stage5
 375              	
 376 08e3 0000     	.Lstage_4_key: .word 0x0
 377 08e5 34746820 	.Lstage_4_s0: .string "4th stage...\n\r"
 377      73746167 
 377      652E2E2E 
 377      0A0D00
 378 08f4 41323020 	.Lstage_4_s1: .string "A20 Gate Enabled.\n\r"
 378      47617465 
 378      20456E61 
 378      626C6564 
 378      2E0A0D00 
 379 0908 4B657962 	.Lstage_4_s2: .string "Keyboard LED Test..."
 379      6F617264 
 379      204C4544 
 379      20546573 
 379      742E2E2E 
 380 091d 28646F6E 	.Lstage_4_s3: .string "(done)\n\r"
 380      65290A0D 
 380      00
 381              	
 382 0926 5B       	.Lstage_4_e0: .ascii "["
 383 0927 5A5A5D00 	.Lstage_4_e1: .string "ZZ]"
 384              	
 385              	stage5:
 386 092b 680000   		push $.Lstage5_s0
 387 092e E8B3F7   		call puts
 388 0931 83C402   		add $0x2, %sp
 389              		
 390 0934 68009C   		push $BOOT_END
 391 0937 6A10     		push $KERNEL_SECT
 392 0939 6A10     		push $BOOT_SECT
 393 093b 680000   		push $drive_tmp
 394 093e E8C1FC   		call read_lba
 395 0941 83F810   	  cmp $KERNEL_SECT, %ax
GAS LISTING boot.s 			page 25


 396 0944 740C     		jz .Lstage5_10E
 397 0946 680000   		push $.Lstage5_e0
 398 0949 E898F7   		call puts
 399 094c 83C402   		add $0x2, %sp
 400 094f E8B1F7   		call reboot
 401              	.Lstage5_10E:
 402 0952 EB28     		jmp stage6
 403              	
 404 0954 35746820 	.Lstage5_s0: .string "5th stage...\n\r"
 404      73746167 
 404      652E2E2E 
 404      0A0D00
 405 0963 4661696C 	.Lstage5_e0: .string "Failure load kernel...\n\r"
 405      75726520 
 405      6C6F6164 
 405      206B6572 
 405      6E656C2E 
 406              	
 407              	
 408              	stage6:
 409 097c 680000   	  push $.Lstage6_s0
 410 097f E862F7   	  call puts
 411 0982 83C402   	  add $0x2, %sp
 412              	.Lstage6_10L:
 413              	  
 414 0985 B400     	  mov $0x0, %ah
 415 0987 CD16     	  int $0x16
 416 0989 3C20     	  cmp $0x20, %al
 417 098b 75F8     	  jne .Lstage6_10L
 418              	
 419 098d B81200   	  mov $0x0012, %ax # VGA 640 * 480
 420 0990 CD10     	  int $0x10
 421              	
 422 0992 EB5C     	  jmp stage7
 423              	
 424 0994 36746820 	.Lstage6_s0: .ascii "6th stage...\n\r\n\r"
 424      73746167 
 424      652E2E2E 
 424      0A0D0A0D 
 425 09a4 5B507573 	.string "[Push SPACE key to protect mode...]\n\r"
 425      68205350 
 425      41434520 
 425      6B657920 
 425      746F2070 
 426              	
 427              	
 428              	
 429 09ca 6690     	.align 4
 430              	
 431 09cc 00000000 	GDT: .quad 0x0000000000000000
 431      00000000 
 432 09d4 FFFF0000 	.cs: .quad 0x00CF9A000000FFFF
 432      009ACF00 
 433 09dc FFFF0000 	.ds: .quad 0x00CF92000000FFFF
 433      0092CF00 
 434              	.gdt_end:
 435              	
GAS LISTING boot.s 			page 26


 436              	.set SEL_CODE, .cs - GDT
 437              	.set SEL_DATA, .ds - GDT
 438              	
 439 09e4 1700     	GDTR: .word .gdt_end - GDT - 1 
 440 09e6 00000000 	      .long GDT
 441              	
 442 09ea 0000     	IDTR: .word 0x0
 443 09ec 00000000 	      .long 0x0
 444              	
 445              	
 446              	
 447              	
 448              	stage7:
 449 09f0 FA       	  cli
 450              	
 451 09f1 0F011600 	  lgdt (GDTR)
 451      00
 452 09f6 0F011E00 	  lidt (IDTR)
 452      00
 453              	  
 454 09fb 0F20C0   	  mov %cr0, %eax
 455 09fe 83C801   	  or $0x1, %ax
 456 0a01 0F22C0   	  mov %eax, %cr0
 457              	
 458 0a04 EB00     	  jmp . + 2
 459 0a06 90       	  nop
 460              	
 461              	.code32
 462              	
 463 0a07 66       	.byte 0x66
 464 0a08 EA000000 	jmp $SEL_CODE, $CODE_32
 464      000800
 465              	
 466              	
 467              	CODE_32:
 468 0a0f 66B81000 	  mov $SEL_DATA, %ax
 469 0a13 8ED8     	  mov %ax, %ds
 470 0a15 8EC0     	  mov %ax, %es
 471 0a17 8EE0     	  mov %ax, %fs
 472 0a19 8EE8     	  mov %ax, %gs
 473 0a1b 8ED0     	  mov %ax, %ss
 474              	  
 475 0a1d B9000800 	  mov $KERNEL_SIZE/4, %ecx
 475      00
 476 0a22 BE009C00 	  mov $BOOT_END, %esi
 476      00
 477 0a27 BF001010 	  mov $KERNEL_LOAD, %edi
 477      00
 478 0a2c FC       	  cld
 479 0a2d F3A5     	  rep movsd
 480              	  
 481 0a2f E9000000 	  jmp KERNEL_LOAD
 481      00
 482              	
 483 0a34 00000000 	.fill BOOT_SIZE - (. - _start), 0x1, 0x0 # padding, 0x2000 = BOOT_SIZE
 483      00000000 
 483      00000000 
GAS LISTING boot.s 			page 27


 483      00000000 
 483      00000000 
GAS LISTING boot.s 			page 28


DEFINED SYMBOLS
          ./define.s:1      *ABS*:0000000000007c00 BOOT_LOAD
          ./define.s:2      *ABS*:0000000000002000 BOOT_SIZE
          ./define.s:3      *ABS*:0000000000000200 SECT_SIZE
          ./define.s:4      *ABS*:0000000000000010 BOOT_SECT
          ./define.s:5      *ABS*:0000000000009c00 BOOT_END
          ./define.s:6      *ABS*:0000000000000010 KERNEL_SECT
          ./define.s:7      *ABS*:0000000000002000 KERNEL_SIZE
          ./define.s:8      *ABS*:00000000000a0000 VRAM
          ./define.s:9      *ABS*:0000000000101000 KERNEL_LOAD
          ./define.s:10     *ABS*:0000000000100000 VECT_BASE
          ./define.s:12     *ABS*:0000000000000010 RING_ITEM_SIZE
          ./define.s:13     *ABS*:000000000000000f RING_INDEX_MASK
              boot.s:8      .text:0000000000000000 _start
              boot.s:15     .text:000000000000005a ipl
              boot.s:71     .text:00000000000000dc drive_tmp
                            *ABS*:0000000000000000 drive.no
                            *ABS*:0000000000000002 drive.cyln.low
                            *ABS*:0000000000000004 drive.head
                            *ABS*:0000000000000006 drive.sect
../modules/real/puts.s:3      .text:00000000000000e4 puts
../modules/real/read_chs.s:16     .text:0000000000000142 read_chs
../modules/real/reboot.s:3      .text:0000000000000103 reboot
              boot.s:106    .text:0000000000000673 stage_2
                            *ABS*:0000000000000008 drive.size
../modules/real/puts.s:25     .text:00000000000000f3 .loop1
../modules/real/reboot.s:22     .text:000000000000011f s_reboot_signal
../modules/real/reboot.s:23     .text:000000000000013d s_reboot_newline
                            *ABS*:0000000000000003 drive.cyln.high
../modules/real/read_chs.s:42     .text:0000000000000172 .read_chs1L
../modules/real/read_chs.s:51     .text:000000000000017f .read_chs1E
../modules/real/read_chs.s:59     .text:000000000000018b .read_chs2E
../modules/real/read_chs.s:76     .data:0000000000000000 drive
              boot.s:82     .text:00000000000001fe BOOT_SIGNATURE
              boot.s:91     .text:0000000000000200 FONT
              boot.s:92     .text:0000000000000200 FONT.seg
              boot.s:93     .text:0000000000000202 FONT.off
              boot.s:94     .text:0000000000000204 ACPI_DATA
              boot.s:95     .text:0000000000000204 ACPI_DATA.adr
              boot.s:96     .text:0000000000000208 ACPI_DATA.len
../modules/real/itoa.s:14     .text:000000000000020c itoa
../modules/real/itoa.s:102    .text:000000000000027c ascii_table
../modules/real/get_drive_param.s:12     .text:000000000000028d get_drive_param
../modules/real/get_font_adr.s:10     .text:00000000000002cd get_font_adr
../modules/real/get_mem_info.s:7      .text:00000000000002ed get_mem_info
                            *ABS*:0000000000000014 E820_RECORD_SIZE
../modules/real/get_mem_info.s:112    .text:0000000000000428 put_mem_info
../modules/real/kbc.s:12     .text:00000000000005a2 KBC_Data_Write
../modules/real/kbc.s:54     .text:00000000000005c0 KBC_Data_Read
../modules/real/kbc.s:98     .text:00000000000005e4 KBC_Cmd_Write
../modules/real/read_lba.s:10     .text:0000000000000602 read_lba
../modules/real/lba_chs.s:9      .text:0000000000000638 lba_chs
              boot.s:183    .text:000000000000074e stage_3rd
              boot.s:258    .text:000000000000080d stage_4
              boot.s:385    .text:000000000000092b stage5
              boot.s:408    .text:000000000000097c stage6
              boot.s:448    .text:00000000000009f0 stage7
GAS LISTING boot.s 			page 29


              boot.s:431    .text:00000000000009cc GDT
              boot.s:432    .text:00000000000009d4 .cs
              boot.s:433    .text:00000000000009dc .ds
              boot.s:434    .text:00000000000009e4 .gdt_end
              boot.s:436    *ABS*:0000000000000008 SEL_CODE
              boot.s:437    *ABS*:0000000000000010 SEL_DATA
              boot.s:439    .text:00000000000009e4 GDTR
              boot.s:442    .text:00000000000009ea IDTR
              boot.s:467    .text:0000000000000a0f CODE_32

NO UNDEFINED SYMBOLS
